Tema 3 IOCLA

Task 1:

Am rulat comanda "objdump -M intel -d nice > nice.dump"
Am analizat fisierul rezultat uitandu-ma la ce se intampla
in "main". Am observat ca se face "push" pe stiva unor valori
apoi CALL la câteva adrese. Am analizat fiecare functie apelata
din main, comentand liniile importante, si am observat ca 
al 4-lea apel, la adresa 0x0804864C <print_flag+0x9b> face 
un apel "read" (despre care am presupus ca este functia de sistem
Linux http://man7.org/linux/man-pages/man2/read.2.html). Analizand
valorile care sunt incarcate pe stiva inainte de apelul functiei
am observat ca se permite citirea a 0x38d (909) octeti, insa
buffer-ul declarat in zona de varibile locale este de dimenisune
0x1b8 (440) octeti.

Vulnerabilitaea: Poate fi executat un BUFFER OVERFLOW la functia de
la adresa 0x0804864C <print_flag+0x9b>

Task 2:

Din analiza primelor trei functii apelate din functia "main"
reiese ca se fac trei apeluri "read" de maxim 198 + 285 + 135 bytes.
In a patra functie sunt permise citirea a maxim 909 octeti, insa
buffer-ul este de 440 octeti. De asemenea, aceasta functie este
diferita de restul pentru ca se incarca in EAX valoarea de la [ebp+0xc],
apoi este executata functia de la acea adresa, urmand apelul functiei
"exit" pentru a nu avea segmentation fault. Din enuntul temei reiese ca
trebuie sa fie afisat un mesaj dupa buffer overflow. In timpul analizei
am descoperit apeluri catre functia "puts" in functiile de la adresele
0x080485E8 si 0x080485B1.

Pentru prima functie generat un input folosind comanda:
    python -c 'print "A"*(198+285+135+440+12) + "\xe8\x85\x04\x08"' > nice_payload
Folosind acest input am obtinut textul: 
"All done! Bye-bye"

Pentru a doua functie am generat input folosind comanda:
    python -c 'print "A"*(198+285+135+440+12) + "\xb1\x85\x04\x08"' > nice_payload
Folosind acest input am obitnut textul: 
"NICE_FLAG{cca9aa3ba79edf63a584b8686fde4629}"

Explicatia comenzii:
    Se printeaza caracterul "A" de (198+285+135+440+12) ori:
        + 198 : pentru a citi maximul din prima functie apelata din main
        + 285 : pentru a citi maximul din a doua functie apelata din main
        + 135 : pentru a citi maximul din a treia functie apelata din main
        + 440 : pentru a umple buffer-ul alocat in a patra functie apelata din main
        + 12 : pentru a suprascrie valorile PANA LA valoarea ce va fi folosita
            ca adresa a unei functii, adica [ebp+0xc]
    Apoi se printeaza adresa functiei, 0x0x080485B1 în format LITTLE ENDIAN

Am adaugat comanda de generare a payload-ului in script-ul "nice_payload_gen.py"

Ruland comanda "python nice_payload_gen.py | ./nice" se obtine textul cautat: 
"NICE_FLAG{cca9aa3ba79edf63a584b8686fde4629}"

Task 3:

Am analizat rezultatul comenzii "objdump -M intel -d naughty > naughty.dump"
la fel ca in primele doua task-uri. Am analizat functiile apelate din "main"
si am observat ca in fiecare functie este verificata câte o valoare din
buffer-ul citit de la STDIN, deci pentru a putea trece de fiecare apel de
functie, valoarea cautata in fiecare functie trebuie sa fie prezenta in payload.
De asemenea, am observat ca a 6-a functie apelata contine vulnerabilitatea de tip
buffer overflow, respectiv apelul functiei a cărei adresă se află în EAX. Pentru 
a obtine payload-ul am scris script-ul "naughty_payload_gen.py" și am obtinut
flag-ul.

Ruland comanda "python naughty_payload_gen.py | ./naughty" se obtine textul cautat: 
"NAUGHTY_FLAG{6077ea84d48f0de7bfc9a85838ecaca3}"

ALTE SURSE DE INSPIRATIE:
    https://0xrick.github.io/binary-exploitation/bof5/
    https://stackoverflow.com/questions/4758175/how-to-use-gdb-with-input-redirection
    https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html
    https://stackoverflow.com/questions/4019508/using-gdb-to-inspect-the-machine-stack

